% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lengthen.R
\name{lengthen_col}
\alias{lengthen_col}
\title{Lengthen Column(s)}
\usage{
lengthen_col(data, cols, delim = "|", trim = TRUE, convert = FALSE)
}
\arguments{
\item{data}{A data.frame.}

\item{cols}{The name of the column(s) in the data.frame to lengthen.}

\item{delim}{A delimiter to split elements within specified columns by
(default: "|").}

\item{trim}{Whether to trim start/end whitespace, as a boolean
(default: \code{TRUE}).}

\item{convert}{Whether to run \code{\link[utils:type.convert]{utils::type.convert()}} with \code{as.is = TRUE} on
new columns. This is useful if the de-concatenated columns are integer,
numeric or logical. NOTE: "NA" strings will \emph{always} be converted to \code{NA}s.}
}
\value{
A data.frame with the specified columns lengthened.
}
\description{
Lengthens values in the column(s) specified, de-concatenating values in
those columns, resulting in duplicated rows that differ only by values in
\code{cols}. NOTE: \code{lengthen_col()} is not the exact reverse of \code{\link[=collapse_col]{collapse_col()}};
see examples.
}
\examples{
z_unique <- tibble::tibble(
  x = c(1, 2, 3, 4, 4),
  y = c("a", "a", "b", "c", "e"),
  z = c("Z", "Y", "X", "W|V", "U")
)

lengthen_col(z_unique, z)

# Data will likely differ after round trip through `collapse_col()` and
# `lengthen_col()` because:
#    1. Duplicate rows (cc_df, row 4) are lost
#    2. New crosses are created (cc_df2, row 6-8)
#    3. Output is sorted by `cols` due to use of `dplyr::group_by()`
#       internally.
cc_df <- tibble::tibble(
  x = c(1, 2, 3, 3, 4, 4, 4),
  y = c("a", "a", "b", "b", "c", "c", "e"),
  z = c("Z", "Y", "X", "X", "W", "V", "U")
)

cc_df2 <- lengthen_col(
  collapse_col(cc_df, c(y, z)),
  c(y, z)
)

if (rlang::is_installed("waldo")) {
  waldo::compare(cc_df, cc_df2)
} else {
  cc_df
  cc_df2
}

}
\seealso{
collapse_col
}
