% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/count.R
\name{count_delim}
\alias{count_delim}
\title{Count Delimited Columns}
\usage{
count_delim(
  data,
  ...,
  delim = "|",
  sort = FALSE,
  name = NULL,
  trim = TRUE,
  convert = FALSE
)
}
\arguments{
\item{data}{A data.frame.}

\item{...}{<\code{\link[rlang:args_data_masking]{data-masking}}> Variables to first
lengthen, then count by.}

\item{delim}{A delimiter to split elements within specified columns by
(default: "|").}

\item{sort}{If \code{TRUE}, will show the largest groups at the top.}

\item{name}{The name of the new column in the output.

If omitted, it will default to \code{n}. If there's already a column called \code{n},
it will use \code{nn}. If there's a column called \code{n} and \code{nn}, it'll use
\code{nnn}, and so on, adding \code{n}s until it gets a new name.}

\item{trim}{Whether to trim start/end whitespace, as a boolean
(default: \code{TRUE}).}

\item{convert}{Whether to run \code{\link[utils:type.convert]{utils::type.convert()}} with \code{as.is = TRUE} on
new columns. This is useful if the de-concatenated columns are integer,
numeric or logical. NOTE: "NA" strings will \emph{always} be converted to \code{NA}s.}
}
\description{
Counts columns when values within them are delimited.
}
\examples{
.df <- tibble::tibble(
    x = 1:3,
    y = c("1|2", "1|3", "2"),
    z = c("1", "2|3", "1|3")
)

# counts undelimited columns like dplyr::count()
count_delim(.df, x)

# counts all delimited values
count_delim(.df, y)

# works for multiple columns that use the same delimiter
count_delim(.df, y, z)

# but not those that use different delimiters
.df2 <- dplyr::mutate(.df, z = stringr::str_replace(z, "\\\\|", "\%"))
.df2

count_delim(.df2, y, z, delim = "\%")

}
