% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unnest.R
\name{unnest_cross}
\alias{unnest_cross}
\title{Unnest data frame list columns}
\usage{
unnest_cross(data, cols, ...)
}
\arguments{
\item{data}{A data.frame.}

\item{cols}{<\code{\link[=tidyr_tidy_select]{tidy-select}}> Columns to unnest.}

\item{...}{
  Arguments passed on to \code{\link[tidyr:chop]{tidyr::unchop}}, \code{\link[tidyr:pack]{tidyr::unpack}}
  \describe{
    \item{\code{keep_empty}}{By default, you get one row of output for each element
of the list your unchopping/unnesting. This means that if there's a
size-0 element (like \code{NULL} or an empty data frame), that entire row
will be dropped from the output. If you want to preserve all rows,
use \code{keep_empty = TRUE} to replace size-0 elements with a single row
of missing values.}
    \item{\code{ptype}}{Optionally, a named list of column name-prototype pairs to
coerce \code{cols} to, overriding the default that will be guessed from
combining the individual values. Alternatively, a single empty ptype
can be supplied, which will be applied to all \code{cols}.}
    \item{\code{names_sep}}{If \code{NULL}, the default, the names will be left
as is. In \code{pack()}, inner names will come from the former outer names;
in \code{unpack()}, the new outer names will come from the inner names.

If a string, the inner and outer names will be used together. In
\code{unpack()}, the names of the new outer columns will be formed by pasting
together the outer and the inner column names, separated by \code{names_sep}. In
\code{pack()}, the new inner names will have the outer names + \code{names_sep}
automatically stripped. This makes \code{names_sep} roughly symmetric between
packing and unpacking.}
    \item{\code{names_repair}}{Used to check that output data frame has valid
names. Must be one of the following options:
\itemize{
\item "minimal": no name repair or checks, beyond basic existence,
\item "unique": make sure names are unique and not empty,
\item "check_unique": (the default), no name repair, but check they are unique,
\item "universal": make the names unique and syntactic
\item a function: apply custom name repair.
\item \link[tidyr]{tidyr_legacy}: use the name repair from tidyr 0.8.
\item a formula: a purrr-style anonymous function (see \code{\link[rlang:as_function]{rlang::as_function()}})
}

See \code{\link[vctrs:vec_as_names]{vctrs::vec_as_names()}} for more details on these terms and the
strategies used to enforce them.}
  }}
}
\description{
Like \code{\link[tidyr:nest]{tidyr::unnest()}} but always produces a cartesian product and does not
requires that list columns be "parallel entries ... of compatible sizes".
}
\examples{
df <- tibble::tibble(
    n = 1:2,
    interjection = list(c("oh", "wow"), "zap"),
    letter = list(c("a", "b", "c"), "d"),
    keep_list = list("please", c("don't", "unnest"))
)
df

# Uses tidyselect semantics, like tidyr::unnest()
unnest_cross(df, cols = tidyselect::starts_with("inter"))

# Works when list column sizes differ, unlike tidyr::unnest()
tryCatch(
    tidyr::unnest(df, cols = c(interjection, letter)),
    error = function(e) message(e)
)
unnest_cross(df, cols = c(interjection, letter))

# Always produces a cartesian product, unlike tidyr::unnest()
df2 <- tibble::tibble(
    n = list(1:2, 3L),
    letter = list(c("a", "b"), "c"),
)
df2
tidyr::unnest(df2, cols = tidyselect::everything())
unnest_cross(df2, cols = tidyselect::everything())

}
