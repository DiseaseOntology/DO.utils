#' Map Terms to Terms of Specified Namespace
#'
#' Map `term` to terms of a specified namespace (e.g. "DOID") using
#' [PyOBO](https://github.com/pyobo/pyobo) (and by dependency other
#' [biopragmatics](https://biopragmatics.github.io/) and
#' [INDRA labs](https://indralab.github.io/) programs; e.g.
#' [GILDA](https://github.com/indralab/gilda),
#' [bioregistry](http://bioregistry.io/)). In INDRA labs
#' terminology, GILDA grounds (predicts matches of) `term` to `namespace` terms.
#'
#' @param terms Term(s) to map, as a character vector.
#' @param namespace Namespace to map terms to (_according to bioregistry_), as a
#'     string.
#'
#' @returns
#' List of results for each term. See [parse_mapping()] and dependencies for
#' details on format of results.
#'
#' @export
pyobo_map <- function(terms, namespace) {
    grounder <- pyobo_gutils$get_grounder(namespace)
    res <- purrr::map(terms, grounder$ground) %>%
        purrr::set_names(terms)

    res
}


#' Unnest Mapping
#'
#' Tidies [pyobo_map()] results stored in the column of a data frame in two
#' steps:
#' 1. Extracts mapping results from specialized `ScoredMatch` python objects
#' (as defined by GILDA).
#' 2. Unnests the results (from list of data frames).
#'
#' @param df A data.frame.
#' @param col The column with `pyobo_map()` results, as a
#'     [tidy-select specification](tidyr::tidyr_tidy_select).
#' @inheritParams parse_term_mapping
#' @inheritParams extract_ScoredMatch
#' @inheritDotParams tidyr::unnest keep_empty:names_repair
#'
#' @returns
#' The input data frame with additional columns `id`, `term` (namespace label),
#' and `score` (mapping score as determined by GILDA). The data frame will
#' have additional rows if `best_score = FALSE` or ties for best score exist
#' for a term.
#'
#' @export
unnest_mapping <- function(df, col, prefix = NULL, prefix_sep = ":",
                           best_only = TRUE, warn_best_gt1 = FALSE, ...) {

    df_unnested <- df %>%
        dplyr::mutate(
            parsed_mapping = parse_mapping(
                {{ col }},
                prefix = prefix,
                prefix_sep = prefix_sep,
                best_only = best_only,
                warn_best_gt1 = warn_best_gt1
            )
        ) %>%
        tidyr::unnest(.data$parsed_mapping, ...) %>%
        dplyr::select(- {{ col }} )

    df_unnested
}


#' Parse Mapping
#'
#' Parses mappings generated by [pyobo_map()] or otherwise produced by the
#' python module [GILDA](https://gilda.readthedocs.io/en/latest/).
#'
#' @param py_gilda_res_list A named list of term mapping lists (see
#'     [parse_term_mapping()]), likely generated by [pyobo_map()].
#' @inheritDotParams extract_ScoredMatch -py_ScoredMatch
#' @inheritDotParams parse_term_mapping -py_gilda_term_mappings
#'
#' @returns
#' List of data frames with the mapping result(s) for each term.
#'
#' @export
parse_mapping <- function(py_gilda_res_list, ...) {
    parsed_list <- purrr::map(
        py_gilda_res_list,
        parse_term_mapping,
        ...
    )

    parsed_list
}


# parse_mapping() utils ---------------------------------------------------

#' Parse Mapping for Single Term (INTERNAL)
#'
#' Parses mappings generated by [pyobo_map()] or otherwise produced by the
#' python module [GILDA](https://gilda.readthedocs.io/en/latest/) AT THE
#' LEVEL of a single input term.
#'
#' @param py_gilda_term_mappings A list of mappings between a single input term
#'     and one or more namespace terms (stored as specialized `ScoredMatch`
#'     python objects, as defined by GILDA; see [extract_ScoredMatch]).
#' @param best_only Whether to return the best scoring result(s) only, as a
#'     boolean. `FALSE` will return all results. **NOTE:** `TRUE` will return
#'     more than one result in the case of ties.
#' @param warn_best_gt1 Whether to warn that best mapping ties exist for
#'     a term.
#' @inheritDotParams extract_ScoredMatch -py_ScoredMatch
#'
#' @returns
#' List of data frames with the mapping result(s) for each term.
parse_term_mapping <- function(py_gilda_term_mappings, best_only = TRUE,
                               warn_best_gt1 = FALSE, ...) {

    # produce empty tibble when no matches to term exist
    if (length(py_gilda_term_mappings) == 0) {
        return(
            tibble::tribble(
                ~id, ~term, ~score,
                NA, NA, NA
            )
        )
    }

    mapping <- purrr::map_dfr(py_gilda_term_mappings, extract_ScoredMatch, ...)

    if (best_only) {
        best_mapping <- mapping %>%
            dplyr::filter(.data$score == max(.data$score, na.rm = TRUE))
        if (warn_best_gt1) {
            warning(names(py_gilda_term_mappings), " has >1 best mapping.")
        }

        return(best_mapping)
    }

    mapping
}

#' Extract ScoredMatch Objects (INTERNAL)
#'
#' Extracts mapping results from specialized `ScoredMatch` python objects
#' (as defined by GILDA) AT THE LEVEL of individual mappings.
#'
#' @param py_ScoredMatch A GILDA ScoredMatch (python) object.
#' @param prefix _Optional_ prefix to add to namespace local unique identifiers
#'     (LUI; e.g. 4, the LUI for "disease" in DO), as a string; preferably to
#'     create a complete namespace ID (e.g. "DOID:4").
#' @param prefix_sep _Optional_ separator placed between `prefix` and
#'     namespace LUIs, as a string. Ignored if `prefix = NULL`.
extract_ScoredMatch <- function(py_ScoredMatch, prefix = NULL,
                                prefix_sep = ":") {
    if (is.null(prefix)) {
        prefix_sep <- NULL
    }

    df <- tibble::tibble(
        id = paste0(prefix, prefix_sep, py_ScoredMatch$term$id),
        term = py_ScoredMatch$term$entry_name,
        score = round(py_ScoredMatch$score, 2)
    )

    df
}
