#' Parse Mapping
#'
#' Parses mappings generated by [pyobo_map()] or otherwise produced by the
#' python module [GILDA](https://gilda.readthedocs.io/en/latest/).
#'
#' @param py_gilda_res_list A named list of term mapping lists (see
#'     [parse_term_mapping()]), likely generated by [pyobo_map()].
#' @inheritDotParams extract_ScoredMatch -py_ScoredMatch
#' @inheritDotParams parse_term_mapping -py_gilda_term_mappings
#'
#' @returns
#' List of data frames with the mapping result(s) for each term.
#'
#' @export
parse_mapping <- function(py_gilda_res_list, ...) {
    parsed_list <- purrr::map(
        py_gilda_res_list,
        parse_term_mapping,
        ...
    )

    parsed_list
}


#' Parse HTML (mat-)table to Dataframe
#'
#' Parses an HTML table or mat-table to a data.frame.
#'
#' @param html A file path to, or a string of, HTML content containing a
#' (mat-)table.
#' @param type The type of table to parse, as a string. One of:
#' - `"table"` (default): A standard HTML table.
#' - `"mat-table"`: An Angular Material table.
#' - `"unknown"`: attempt to parse any existing table of either type.
#' @param n The position of the table to parse, as a positive integer (default:
#' 1).
#' @returns A `tibble` with the table content.
#' @export
parse_html_table <- function(html, type = "table", n = 1L) {
    stopifnot(
        "`n` must be a positive integer specifying a table position" =
            is.integer(n) && sign(n) == 1
    )
    type <- match.arg(type, c("table", "mat-table", "unknown"))
    parsed <- rvest::read_html(html)
    # extract only the first table
    if (type %in% c("table", "unknown")) {
        df_list <- rvest::html_table(parsed)
        has_table_n(df_list, n)
        out <- df_list[[n]]
    }

    if (type == "mat-table" || (type == "unknown" && nrow(out) == 0)) {
        h_tables <- rvest::html_elements(parsed, "table")
        has_table_n(h_tables, n)
        h_table <- h_tables[[n]]
        h_cells <- rvest::html_elements(h_table, "mat-header-cell")
        header <- stringr::str_trim(rvest::html_text(h_cells))
        b_rows <- rvest::html_elements(h_table, "mat-row")
        body_list <- lapply(
            b_rows,
            function(x) {
                stringr::str_trim(
                    rvest::html_text(rvest::html_elements(x, "mat-cell"))
                )
            }
        )
        body_matrix <- do.call(rbind, body_list)
        head_n <- length(header)
        col_n <- ncol(body_matrix)
        if (head_n == col_n) {
            colnames(body_matrix) <- header
            out <- tibble::as_tibble(body_matrix)
        } else if (head_n == 0) {
            rlang::warn(
                "header could not be identified in table. Unique column names will be generated..."
            )
            out <- tibble::as_tibble(body_matrix, .name_repair = "universal")
        } else {
            stop(
                paste0(
                    "header length did not match column number: ",
                    head_n, " vs. ", col_n, " columns"
                )
            )
        }
    }

    if (nrow(out) == 0) stop("No table could be identified to tidy.")
    out
}


# parse_html_table() helpers ----------------------------------------------

#' Check if Table Position Exists (INTERNAL)
#'
#' @param tables_html A list of extracted HTML tables.
#' @param choice The table position to check, as a positive integer.
#'
#' @noRd
has_table_n <- function(tables_html, choice) {
    table_n <- length(tables_html)
    if (table_n < choice) {
        msg <- "`n` does not correspond to an existing table position."
        if (table_n > 1) {
            msg_n <- paste0("Possible positions include 1-", table_n)
        } else {
            msg_n <- "Maximum of 1 table identified."
        }
        stop(paste0(msg, msg_n))
    }
}


# parse_mapping() utils ---------------------------------------------------

#' Parse Mapping for Single Term (INTERNAL)
#'
#' Parses mappings generated by [pyobo_map()] or otherwise produced by the
#' python module [GILDA](https://gilda.readthedocs.io/en/latest/) AT THE
#' LEVEL of a single input term.
#'
#' @param py_gilda_term_mappings A list of mappings between a single input term
#'     and one or more namespace terms (stored as specialized `ScoredMatch`
#'     python objects, as defined by GILDA; see [extract_ScoredMatch]).
#' @param best_only Whether to return the best scoring result(s) only, as a
#'     boolean. `FALSE` will return all results. **NOTE:** `TRUE` will return
#'     more than one result in the case of ties.
#' @param warn_best_gt1 Whether to warn that best mapping ties exist for
#'     a term.
#' @inheritDotParams extract_ScoredMatch -py_ScoredMatch
#'
#' @returns
#' List of data frames with the mapping result(s) for each term.
#'
#' @keywords internal
parse_term_mapping <- function(py_gilda_term_mappings, best_only = TRUE,
                               warn_best_gt1 = FALSE, ...) {

    # produce empty tibble when no matches to term exist
    if (length(py_gilda_term_mappings) == 0) {
        return(
            tibble::tribble(
                ~id, ~term, ~score,
                NA, NA, NA
            )
        )
    }

    mapping <- purrr::map_dfr(py_gilda_term_mappings, extract_ScoredMatch, ...)

    if (best_only) {
        best_mapping <- mapping %>%
            dplyr::filter(.data$score == max(.data$score, na.rm = TRUE))
        if (warn_best_gt1) {
            warning(names(py_gilda_term_mappings), " has >1 best mapping.")
        }

        return(best_mapping)
    }

    mapping
}

#' Extract ScoredMatch Objects (INTERNAL)
#'
#' Extracts mapping results from specialized `ScoredMatch` python objects
#' (as defined by GILDA) AT THE LEVEL of individual mappings.
#'
#' @param py_ScoredMatch A GILDA ScoredMatch (python) object.
#' @param prefix _Optional_ prefix to add to namespace local unique identifiers
#'     (LUI; e.g. 4, the LUI for "disease" in DO), as a string; preferably to
#'     create a complete namespace ID (e.g. "DOID:4").
#' @param prefix_sep _Optional_ separator placed between `prefix` and
#'     namespace LUIs, as a string. Ignored if `prefix = NULL`.
#'
#' @keywords internal
extract_ScoredMatch <- function(py_ScoredMatch, prefix = NULL,
                                prefix_sep = ":") {
    if (is.null(prefix)) {
        prefix_sep <- NULL
    }

    df <- tibble::tibble(
        id = paste0(prefix, prefix_sep, py_ScoredMatch$term$id),
        term = py_ScoredMatch$term$entry_name,
        score = round(py_ScoredMatch$score, 2)
    )

    df
}
