#' Parse Mapping
#'
#' Parses mappings generated by [pyobo_map()] or otherwise produced by the
#' python module [GILDA](https://gilda.readthedocs.io/en/latest/).
#'
#' @param py_gilda_res_list A named list of term mapping lists (see
#'     [parse_term_mapping()]), likely generated by [pyobo_map()].
#' @inheritDotParams extract_ScoredMatch -py_ScoredMatch
#' @inheritDotParams parse_term_mapping -py_gilda_term_mappings
#'
#' @returns
#' List of data frames with the mapping result(s) for each term.
#'
#' @export
parse_mapping <- function(py_gilda_res_list, ...) {
    parsed_list <- purrr::map(
        py_gilda_res_list,
        parse_term_mapping,
        ...
    )

    parsed_list
}


#' Parse Error Messages from Fastobo Validator
#'
#' Reads saved error messages from fastobo-validator and parses them into a
#' tibble. Assumes the input will specify errors including CURIEs.
#'
#' @param file Path to the file containing the error messages. Output should be
#' saved on the commandline by assigning stdout to a file, e.g.
#' fastobo-validator input.obo > input_err.txt
#'
#' @returns A tibble with columns `id`, `where`, and `err`.
#'
#' @export
parse_fastobo_validator <- function(file) {
    parsed <- readr::read_file(file) |>
        stringr::str_match_all(
            "--> (?<where>.+) (?<id>[^:]+:[0-9]+)[^\n]*\n[:space:]*(?<err>[^\n]+)"
        )
    out <- tibble::as_tibble(parsed[[1]][, -1]) |>
        dplyr::relocate("where", "err", .after = "id")

    out
}


# parse_mapping() utils ---------------------------------------------------

#' Parse Mapping for Single Term (INTERNAL)
#'
#' Parses mappings generated by [pyobo_map()] or otherwise produced by the
#' python module [GILDA](https://gilda.readthedocs.io/en/latest/) AT THE
#' LEVEL of a single input term.
#'
#' @param py_gilda_term_mappings A list of mappings between a single input term
#'     and one or more namespace terms (stored as specialized `ScoredMatch`
#'     python objects, as defined by GILDA; see [extract_ScoredMatch]).
#' @param best_only Whether to return the best scoring result(s) only, as a
#'     boolean. `FALSE` will return all results. **NOTE:** `TRUE` will return
#'     more than one result in the case of ties.
#' @param warn_best_gt1 Whether to warn that best mapping ties exist for
#'     a term.
#' @inheritDotParams extract_ScoredMatch -py_ScoredMatch
#'
#' @returns
#' List of data frames with the mapping result(s) for each term.
#'
#' @keywords internal
parse_term_mapping <- function(py_gilda_term_mappings, best_only = TRUE,
                               warn_best_gt1 = FALSE, ...) {

    # produce empty tibble when no matches to term exist
    if (length(py_gilda_term_mappings) == 0) {
        return(
            tibble::tribble(
                ~id, ~term, ~score,
                NA, NA, NA
            )
        )
    }

    mapping <- purrr::map_dfr(py_gilda_term_mappings, extract_ScoredMatch, ...)

    if (best_only) {
        best_mapping <- mapping %>%
            dplyr::filter(.data$score == max(.data$score, na.rm = TRUE))
        if (warn_best_gt1) {
            warning(names(py_gilda_term_mappings), " has >1 best mapping.")
        }

        return(best_mapping)
    }

    mapping
}

#' Extract ScoredMatch Objects (INTERNAL)
#'
#' Extracts mapping results from specialized `ScoredMatch` python objects
#' (as defined by GILDA) AT THE LEVEL of individual mappings.
#'
#' @param py_ScoredMatch A GILDA ScoredMatch (python) object.
#' @param prefix _Optional_ prefix to add to namespace local unique identifiers
#'     (LUI; e.g. 4, the LUI for "disease" in DO), as a string; preferably to
#'     create a complete namespace ID (e.g. "DOID:4").
#' @param prefix_sep _Optional_ separator placed between `prefix` and
#'     namespace LUIs, as a string. Ignored if `prefix = NULL`.
#'
#' @keywords internal
extract_ScoredMatch <- function(py_ScoredMatch, prefix = NULL,
                                prefix_sep = ":") {
    if (is.null(prefix)) {
        prefix_sep <- NULL
    }

    df <- tibble::tibble(
        id = paste0(prefix, prefix_sep, py_ScoredMatch$term$id),
        term = py_ScoredMatch$term$entry_name,
        score = round(py_ScoredMatch$score, 2)
    )

    df
}
