#' Extract PubMed ID
#'
#' `extract_pmid` is a generic function that extracts PubMed IDs.
#'
#' @param x An object.
#' @param ... Arguments passed on to methods.
#'
#' @returns
#' A character vector of PubMed IDs, except for the `extract_pmid.elink_list`
#' method which returns a list of PubMed ID character vectors.
#'
#' @family extract_pmid_methods
#' @export
extract_pmid <- function(x, ...) {
    UseMethod("extract_pmid")
}

#' @rdname extract_pmid
#' @export
extract_pmid.pm_search <- function(x, ...) {
    x$ids
}

#' @rdname extract_pmid
#' @export
extract_pmid.pmc_search <- function(x, ...) {
    pmids <- x$pmids

    if (length(pmids) == 0) {
        stop("No PMIDs available. Was 'pmid' set to TRUE in search_pmc()?")
    }

    pmid_missing <- is.na(pmids)
    if (any(pmid_missing)) {
        n_missing <- sum(pmid_missing)
        n_id <- length(pmids)
        pct_missing <- round(n_missing / n_id, 2)

        warning(
            n_missing, " of ", n_id, " (", pct_missing, "%)",
            " PMIDs are missing. Consider extracting PMCIDs.",
            call. = FALSE
        )
    }

    pmids
}

#' @rdname extract_pmid
#' @export
extract_pmid.data.frame <- function(x, ...) {
    df <- dplyr::rename_with(x, .fn = tolower)

    if (!"pmid" %in% names(df)) {
        stop("PMID column could not be identified. Name must be 'pmid' or 'PMID').")
    }

    pmids <- df$pmid

    pmid_missing <- is.na(pmids)
    if (any(pmid_missing)) {
        n_missing <- sum(pmid_missing)
        n_id <- length(pmids)
        pct_missing <- round(n_missing / n_id, 2)

        warning(
            n_missing, " of ", n_id, " (", pct_missing, "%)",
            " PMIDs are missing. Consider extracting alternate IDs, if available.",
            call. = FALSE
        )
    }

    pmids
}


#' Extract PubMed ID from elink object
#'
#' Extract PubMed ID from an `elink` object.
#'
#' @param x An `elink` object, generated by [rentrez::entrez_link] and it's
#' derivatives (e.g. [citedby_pmid]).
#' @param linkname linkname as specified for [Entrez API](https://eutils.ncbi.nlm.nih.gov/entrez/query/static/entrezlinks.html);
#' only necessary if more than one `linkname` is returned from PubMed.
#' @param quietly Suppress PubMed linkname message when `linkname` is not
#' specified and multiple results exist in an `elink` object.
#' @param no_result The type of condition that should be signaled when no PubMed
#'     results exist in a response; one of "error" (default), "warning",
#'     "message" or "none".
#' @param ... Unused, included for generic consistency only.
#'
#' @family extract_pmid_methods
#' @export
extract_pmid.elink <- function(x, linkname = NULL, quietly = FALSE,
                               no_result = "error", ...) {
    no_result <- match.arg(
        no_result,
        c("error", "warning", "message", "none")
    )

    nm <- names(x$links)
    pm_res <- stringr::str_detect(nm, "_pubmed")
    pm_n <- sum(pm_res)

    if (pm_n == 0) {
        if (no_result != "none") {
            rlang::signal(
                class = c("no_result", no_result),
                message = "0 PubMed citedby results"
            )
        }
        return(NULL)
    }

    if (pm_n > 1 && is.null(linkname)) {
        stop(
            "linkname must be specified when elink object contains more than
                one pubmed result. Identified linknames: ",
            vctr_to_string(nm[pm_res], delim = ", ")
        )
    }

    pmid <- if(!is.null(linkname)) {
        x$links[[linkname]]
    } else {
        if (!quietly && length(nm) > 1) {
            message("PubMed linkname identified: ", nm[pm_res])
        }
        x$links[[pm_res]]
    }

    pmid
}


#' Extract PubMed ID from elink_list object
#'
#' Extract PubMed ID from an `elink_list` object.
#'
#' @param x An `elink_list` object, generated by [rentrez::entrez_link] and it's
#' derivatives (e.g. [citedby_pmid]) when `by_id = TRUE` .
#' @param ... Additional arguments passed on to [extract_pmid.elink()].
#' @inheritParams extract_pmid.elink
#'
#' @family extract_pmid_methods
#' @export
extract_pmid.elink_list <- function(x, no_result = "warning", ...) {
    cond_msg <- NULL
    res <- purrr::map2(
        x,
        names(x),
        function(vals, nm) {
            tryCatch(
                extract_pmid(vals, no_result = no_result, ...),
                # make no_result message more informative & discard when signaled
                no_result = function(cond) {
                    cond_type <- dplyr::nth(class(cond), -2)
                    if (cond_type == "error") {
                        rlang::signal(
                            message = paste0(nm, ": ", cond$message),
                            class = c(class(cond)[1], cond_type)
                        )
                    } else {
                        cond_msg <<- cond$message
                        return(NULL)
                    }
                }
            )
        }
    )
    names(res) <- names(x)

    # keep only those with results
    out <- purrr::compact(res)
    discard <- names(res)[!names(res) %in% names(out)]
    if (no_result != "none" & length(discard) > 0) {
        rlang::signal(
            message = c(
                paste0("Discarded (", cond_msg, ")"),
                purrr::set_names(discard, rep("i", length(discard)))
            ),
            class = c("no_result", no_result),
            use_cli_format = TRUE
        )
    }

    out
}


#' Extract Publication Date from PubMed Citations
#'
#' Extracts most complete publication date possible from Pubmed citations.
#'
#' This function uses a step-wise approach, attempting first to extract a full
#' date, subsequently a year & month and, if that is not available, just the
#' year. This approach is designed to prevent accidental matches to year values
#' found in titles.
#'
#' NOTE: When the day is missing, this function will return a full date using
#' the first day of the month. When both the month and day are missing, this\
#' function will return the first day of the year.
#'
#' @param citation character vector of PubMed citations
#'
#' @md
#' @export
extract_pm_date <- function(citation) {

    # define regex patterns
    ymd_regex <- "[12][0-9]{3} (Jan|Feb|Ma[ry]|Apr|Ju[nl]|Aug|Sep|Oct|Nov|Dec) [0-9]{1,2}"
    ym_regex <- "[12][0-9]{3} (Jan|Feb|Ma[ry]|Apr|Ju[nl]|Aug|Sep|Oct|Nov|Dec)"
    y_regex <- "[12][0-9]{3}"

    # stepwise identification to avoid picking up dates from titles, as much
    #   as possible
    pub_date <- dplyr::case_when(
        stringr::str_detect(citation, ymd_regex) ~
            lubridate::ymd(stringr::str_extract(citation, ymd_regex)),
        # if lacking day, will use first day of month
        stringr::str_detect(citation, ym_regex) ~
            lubridate::ym(stringr::str_extract(citation, ym_regex)),
        stringr::str_detect(citation, y_regex) ~
            # if year only, not ideal (use first day of year)
            lubridate::ymd(
                paste0(
                    stringr::str_extract(citation, y_regex),
                    "-01-01"
                )
            )
    )

    pub_date
}
